"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Node_1 = require("./Node");
const Import_1 = require("./Import");
const prettier_1 = __importStar(require("prettier"));
const is_plain_object_1 = require("./is-plain-object");
const ConditionalOutput_1 = require("./ConditionalOutput");
const index_1 = require("./index");
// We only have a single top-level Code.toStringWithImports running at a time,
// so use a global var to capture this contextual state.
let usedConditionals = [];
class Code extends Node_1.Node {
    constructor(literals, placeholders) {
        super();
        this.literals = literals;
        this.placeholders = placeholders;
        // Used by joinCode
        this.trim = false;
    }
    /**
     * Returns the code with any necessary import statements prefixed.
     *
     * `path` is the intended file name of this code; it is used to know whether we
     * can skip import statements that would important from our own file.
     *
     * This method will also use any local `.prettierrc` settings, hence needs
     * to return a `Promise<String>`.
     */
    toStringWithImports(opts) {
        const { path = '', forceDefaultImport, prefix } = opts || {};
        const ourModulePath = path.replace(/\.[tj]sx?/, '');
        if (forceDefaultImport) {
            this.deepReplaceNamedImports(forceDefaultImport);
        }
        usedConditionals = this.deepConditionalOutput();
        const imports = this.deepFindImports();
        const defs = this.deepFindDefs();
        assignAliasesIfNeeded(defs, imports, ourModulePath);
        const importPart = Import_1.emitImports(imports, ourModulePath);
        const bodyPart = this.generateCode();
        const maybePrefix = prefix ? `${prefix}\n` : '';
        return maybePrettyWithConfig(maybePrefix + importPart + '\n' + bodyPart);
    }
    /**
     * Returns the formatted code, without any imports.
     *
     * Note that we don't use `.prettierrc` b/c that requires async I/O to resolve.
     */
    toString() {
        return maybePretty(this.generateCode());
    }
    get childNodes() {
        return this.placeholders;
    }
    toCodeString() {
        const code = this.generateCode();
        return this.trim ? code.trim() : code;
    }
    deepFindImports() {
        const imports = [];
        let todo = [this];
        while (todo.length > 0) {
            const placeholder = todo.shift();
            if (placeholder instanceof Import_1.Import) {
                imports.push(placeholder);
            }
            else if (placeholder instanceof Node_1.Node) {
                todo = [...todo, ...placeholder.childNodes];
            }
            else if (placeholder instanceof ConditionalOutput_1.MaybeOutput) {
                if (usedConditionals.includes(placeholder.parent)) {
                    todo = [...todo, placeholder.code];
                }
            }
            else if (Array.isArray(placeholder)) {
                todo = [...todo, ...placeholder];
            }
        }
        return imports;
    }
    deepFindDefs() {
        const defs = [];
        let todo = [this];
        while (todo.length > 0) {
            const placeholder = todo.shift();
            if (placeholder instanceof Def) {
                defs.push(placeholder);
            }
            else if (placeholder instanceof Node_1.Node) {
                todo = [...todo, ...placeholder.childNodes];
            }
            else if (placeholder instanceof ConditionalOutput_1.MaybeOutput) {
                if (usedConditionals.includes(placeholder.parent)) {
                    todo = [...todo, placeholder.code];
                }
            }
            else if (Array.isArray(placeholder)) {
                todo = [...todo, ...placeholder];
            }
        }
        return defs;
    }
    deepConditionalOutput() {
        const used = [];
        let todo = [this];
        while (todo.length > 0) {
            const placeholder = todo.shift();
            if (placeholder instanceof ConditionalOutput_1.ConditionalOutput) {
                used.push(placeholder);
                todo = [...todo, ...placeholder.declarationSiteCode.childNodes];
            }
            else if (placeholder instanceof Node_1.Node) {
                todo = [...todo, ...placeholder.childNodes];
            }
            else if (Array.isArray(placeholder)) {
                todo = [...todo, ...placeholder];
            }
        }
        return used;
    }
    deepReplaceNamedImports(forceDefaultImport) {
        // Keep a map of module name --> symbol we're importing, i.e. protobufjs/simple is _m1
        const assignedNames = {};
        function getName(source) {
            let name = assignedNames[source];
            if (!name) {
                name = `_m${Object.values(assignedNames).length}`;
                assignedNames[source] = name;
            }
            return name;
        }
        let todo = [this];
        while (todo.length > 0) {
            const placeholder = todo.shift();
            if (placeholder instanceof Node_1.Node) {
                const array = placeholder.childNodes;
                for (let i = 0; i < array.length; i++) {
                    const maybeImp = array[i];
                    if (maybeImp instanceof Import_1.ImportsName && forceDefaultImport.includes(maybeImp.source)) {
                        const name = getName(maybeImp.source);
                        array[i] = index_1.code `${new Import_1.ImportsDefault(name, maybeImp.source)}.${maybeImp.sourceSymbol || maybeImp.symbol}`;
                    }
                }
                todo = [...todo, ...placeholder.childNodes];
            }
            else if (Array.isArray(placeholder)) {
                todo = [...todo, ...placeholder];
            }
        }
    }
    generateCode() {
        const { literals, placeholders } = this;
        let result = '';
        // interleave the literals with the placeholders
        for (let i = 0; i < placeholders.length; i++) {
            result += literals[i] + deepGenerate(placeholders[i]);
        }
        // add the last literal
        result += literals[literals.length - 1];
        return result;
    }
}
exports.Code = Code;
function deepGenerate(object) {
    let result = '';
    let todo = [object];
    while (todo.length > 0) {
        const current = todo.shift();
        if (Array.isArray(current)) {
            todo = [...todo, ...current];
        }
        else if (current instanceof Node_1.Node) {
            result += current.toCodeString();
        }
        else if (current instanceof ConditionalOutput_1.MaybeOutput) {
            if (usedConditionals.includes(current.parent)) {
                result += current.code.toCodeString();
            }
        }
        else if (current === null) {
            result += 'null';
        }
        else if (current !== undefined) {
            if (is_plain_object_1.isPlainObject(current)) {
                result += JSON.stringify(current);
            }
            else {
                result += current.toString();
            }
        }
        else {
            result += 'undefined';
        }
    }
    return result;
}
exports.deepGenerate = deepGenerate;
const configPromise = prettier_1.resolveConfig('./');
async function maybePrettyWithConfig(input) {
    try {
        const config = await configPromise;
        return prettier_1.default.format(input.trim(), { parser: 'typescript', ...config });
    }
    catch (e) {
        return input; // assume it's invalid syntax and ignore
    }
}
/** Finds any namespace collisions of a named import colliding with def and assigns the import an alias it. */
function assignAliasesIfNeeded(defs, imports, ourModulePath) {
    const defNames = new Set();
    defs.forEach((def) => defNames.add(def.symbol));
    // A mapping of original to assigned alias, i.e. Foo@foo --> Foo2
    const assignedAliases = {};
    let j = 1;
    imports.forEach((i) => {
        if (i instanceof Import_1.ImportsName &&
            !(Import_1.sameModule(i.source, ourModulePath) || (i.definedIn && Import_1.sameModule(i.definedIn, ourModulePath)))) {
            if (defNames.has(i.symbol)) {
                // Look for an existing alias
                const key = `${i.symbol}@${i.source}`;
                let alias = assignedAliases[key];
                if (!alias) {
                    alias = `${i.symbol}${j++}`;
                    assignedAliases[key] = alias;
                }
                // Move the original symbol over
                i.sourceSymbol = i.symbol;
                i.symbol = alias;
            }
        }
    });
}
function maybePretty(input) {
    try {
        return prettier_1.default.format(input.trim(), { parser: 'typescript' });
    }
    catch (e) {
        return input; // assume it's invalid syntax and ignore
    }
}
/**
 * Represents a symbol defined in the current file.
 *
 * We use this to know if a symbol imported from a different file is going to
 * have a namespace collision.
 */
class Def extends Node_1.Node {
    constructor(symbol) {
        super();
        this.symbol = symbol;
    }
    toCodeString() {
        return this.symbol;
    }
    /** Any potentially string/SymbolSpec/Code nested nodes within us. */
    get childNodes() {
        return [];
    }
}
exports.Def = Def;
