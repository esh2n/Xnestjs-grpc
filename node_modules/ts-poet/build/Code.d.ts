import { Node } from './Node';
export declare class Code extends Node {
    private literals;
    private placeholders;
    trim: boolean;
    constructor(literals: TemplateStringsArray, placeholders: any[]);
    /**
     * Returns the code with any necessary import statements prefixed.
     *
     * `path` is the intended file name of this code; it is used to know whether we
     * can skip import statements that would important from our own file.
     *
     * This method will also use any local `.prettierrc` settings, hence needs
     * to return a `Promise<String>`.
     */
    toStringWithImports(opts?: {
        path?: string;
        forceDefaultImport?: string[];
        prefix?: string;
    }): Promise<string>;
    /**
     * Returns the formatted code, without any imports.
     *
     * Note that we don't use `.prettierrc` b/c that requires async I/O to resolve.
     */
    toString(): string;
    get childNodes(): unknown[];
    toCodeString(): string;
    private deepFindImports;
    private deepFindDefs;
    private deepConditionalOutput;
    private deepReplaceNamedImports;
    private generateCode;
}
export declare function deepGenerate(object: unknown): string;
/**
 * Represents a symbol defined in the current file.
 *
 * We use this to know if a symbol imported from a different file is going to
 * have a namespace collision.
 */
export declare class Def extends Node {
    symbol: string;
    constructor(symbol: string);
    toCodeString(): string;
    /** Any potentially string/SymbolSpec/Code nested nodes within us. */
    get childNodes(): Node[];
}
