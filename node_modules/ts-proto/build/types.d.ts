import { google } from '../build/pbjs';
import { Code, Import } from 'ts-poet';
import { Options } from './main';
import FieldDescriptorProto = google.protobuf.FieldDescriptorProto;
import CodeGeneratorRequest = google.protobuf.compiler.CodeGeneratorRequest;
import EnumDescriptorProto = google.protobuf.EnumDescriptorProto;
import FileDescriptorProto = google.protobuf.FileDescriptorProto;
import DescriptorProto = google.protobuf.DescriptorProto;
import MethodDescriptorProto = google.protobuf.MethodDescriptorProto;
import ServiceDescriptorProto = google.protobuf.ServiceDescriptorProto;
/** Based on https://github.com/dcodeIO/protobuf.js/blob/master/src/types.js#L37. */
export declare function basicWireType(type: FieldDescriptorProto.Type): number;
export declare function basicLongWireType(type: FieldDescriptorProto.Type): number | undefined;
/** Returns the type name without any repeated/required/etc. labels. */
export declare function basicTypeName(typeMap: TypeMap, field: FieldDescriptorProto, options: Options, typeOptions?: {
    keepValueType?: boolean;
}): Code;
/** Returns the Reader method for the primitive's read/write call. */
export declare function toReaderCall(field: FieldDescriptorProto): string;
export declare function packedType(type: FieldDescriptorProto.Type): number | undefined;
export declare function defaultValue(typeMap: TypeMap, field: FieldDescriptorProto, options: Options): any;
/** A map of proto type name, e.g. `foo.Message.Inner`, to module/class name, e.g. `foo`, `Message_Inner`. */
export declare type TypeMap = Map<string, [string, string, DescriptorProto | EnumDescriptorProto]>;
/** Scans all of the proto files in `request` and builds a map of proto typeName -> TS module/name. */
export declare function createTypeMap(request: CodeGeneratorRequest, options: Options): TypeMap;
export declare function isPrimitive(field: FieldDescriptorProto): boolean;
export declare function isBytes(field: FieldDescriptorProto): boolean;
export declare function isMessage(field: FieldDescriptorProto): boolean;
export declare function isEnum(field: FieldDescriptorProto): boolean;
export declare function isWithinOneOf(field: FieldDescriptorProto): boolean;
export declare function isWithinOneOfThatShouldBeUnion(options: Options, field: FieldDescriptorProto): boolean;
export declare function isRepeated(field: FieldDescriptorProto): boolean;
export declare function isLong(field: FieldDescriptorProto): boolean;
export declare function isMapType(typeMap: TypeMap, messageDesc: DescriptorProto, field: FieldDescriptorProto, options: Options): boolean;
export declare function isTimestamp(field: FieldDescriptorProto): boolean;
export declare function isValueType(field: FieldDescriptorProto): boolean;
export declare function isLongValueType(field: FieldDescriptorProto): boolean;
export declare function isEmptyType(typeName: string): boolean;
export declare function valueTypeName(typeName: string, options?: Options): Code | undefined;
/** Maps `.some_proto_namespace.Message` to a TypeName. */
export declare function messageToTypeName(typeMap: TypeMap, protoType: string, options: Options, typeOptions?: {
    keepValueType?: boolean;
    repeated?: boolean;
}): Code;
export declare function getEnumMethod(typeMap: TypeMap, enumProtoType: string, methodSuffix: string): Import;
/** Return the TypeName for any field (primitive/message/etc.) as exposed in the interface. */
export declare function toTypeName(typeMap: TypeMap, messageDesc: DescriptorProto, field: FieldDescriptorProto, options: Options): Code;
export declare function detectMapType(typeMap: TypeMap, messageDesc: DescriptorProto, fieldDesc: FieldDescriptorProto, options: Options): {
    messageDesc: DescriptorProto;
    keyType: Code;
    valueType: Code;
} | undefined;
export declare function requestType(typeMap: TypeMap, methodDesc: MethodDescriptorProto, options: Options): Code;
export declare function responseType(typeMap: TypeMap, methodDesc: MethodDescriptorProto, options: Options): Code;
export declare function responsePromise(typeMap: TypeMap, methodDesc: MethodDescriptorProto, options: Options): Code;
export declare function responseObservable(typeMap: TypeMap, methodDesc: MethodDescriptorProto, options: Options): Code;
export interface BatchMethod {
    methodDesc: MethodDescriptorProto;
    uniqueIdentifier: string;
    singleMethodName: string;
    inputFieldName: string;
    inputType: Code;
    outputFieldName: string;
    outputType: Code;
    mapType: boolean;
}
export declare function detectBatchMethod(typeMap: TypeMap, fileDesc: FileDescriptorProto, serviceDesc: ServiceDescriptorProto, methodDesc: MethodDescriptorProto, options: Options): BatchMethod | undefined;
