"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visit = void 0;
const pbjs_1 = require("../build/pbjs");
var FileDescriptorProto = pbjs_1.google.protobuf.FileDescriptorProto;
const sourceInfo_1 = require("./sourceInfo");
const case_1 = require("./case");
function visit(proto, sourceInfo, messageFn, options, enumFn = () => { }, tsPrefix = '', protoPrefix = '') {
    const isRootFile = proto instanceof FileDescriptorProto;
    const childEnumType = isRootFile ? sourceInfo_1.Fields.file.enum_type : sourceInfo_1.Fields.message.enum_type;
    proto.enumType.forEach((enumDesc, index) => {
        // I.e. Foo_Bar.Zaz_Inner
        const protoFullName = protoPrefix + enumDesc.name;
        // I.e. FooBar_ZazInner
        const tsFullName = tsPrefix + case_1.maybeSnakeToCamel(enumDesc.name, options);
        const nestedSourceInfo = sourceInfo.open(childEnumType, index);
        enumFn(tsFullName, enumDesc, nestedSourceInfo, protoFullName);
    });
    const messages = proto instanceof FileDescriptorProto ? proto.messageType : proto.nestedType;
    const childType = isRootFile ? sourceInfo_1.Fields.file.message_type : sourceInfo_1.Fields.message.nested_type;
    messages.forEach((message, index) => {
        // I.e. Foo_Bar.Zaz_Inner
        const protoFullName = protoPrefix + message.name;
        // I.e. FooBar_ZazInner
        const tsFullName = tsPrefix + case_1.maybeSnakeToCamel(messageName(message), options);
        const nestedSourceInfo = sourceInfo.open(childType, index);
        messageFn(tsFullName, message, nestedSourceInfo, protoFullName);
        visit(message, nestedSourceInfo, messageFn, options, enumFn, tsFullName + '_', protoFullName + '.');
    });
}
exports.visit = visit;
const builtInNames = ['Date'];
/** Potentially suffixes `Message` to names to avoid conflicts, i.e. with `Date`. */
function messageName(message) {
    const { name } = message;
    return builtInNames.includes(name) ? `${name}Message` : name;
}
